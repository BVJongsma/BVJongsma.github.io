---
layout: dinky
---

<!-- navigation at the top of the page -->
<ul>
    <li><a href="#implementation">Implementation</a></li>
    <ul>
        <li><a href="#knowledge-and-rule-representation">Knowledge and rule representation</a></li>
        <ul>
            <li><a href="#card-player-representation">Card and player representation</a></li>
            <li><a href="#formal-rules">Rules that players can use to determine more information</a></li>
        </ul>
        <li><a href="#the-kripke-model">The Kripke Model</a></li>
    </ul>
    <li><a href="#taking-a-turn">Taking a Turn</a></li>
    <ul>
        <li><a href="#show-a-card">Asking for cards: showing a card</a></li>
        <li><a href="#dont-show-a-card">Asking for cards: not showing a card</a></li>
        <li><a href="#guess-envelope-content">‘Guessing’ the content of the envelope</a></li>
        <li><a href="#model-update">After a turn: updating the model</a></li>
    </ul>
    <li><a href="#download-the-model">Download the model</a></li>
</ul>
<!-- section 5: implementation-->
<div id="implementation">
    <h1>Implementation</h1>
    <!-- subsection 5.1: knowledge and rule representation -->
    <div id="knowledge-and-rule-representation">
        <h2>Knowledge and rule representation</h2>
        <!--5.1.1. card and player representation-->
        <div id="card-player-representation">
            <h3>Card and player representation</h3>
            <p>
                There are two different card categories: weapon and suspect.
                These are represented by the following sets:
            </p>
            <ul>
                <li>
                    Weapons = {axe, candle, dagger, handgun, lead, rope, wrench}
                </li>
                <li>
                    Suspects = {Scarlet, Mustard, Green, Plum}
                </li>
            </ul>
            <p>
                Note that the cards in the weapon category are slightly different compared to the cards in the original Clue game.
                Instead of 'spanner', 'wrench' was used because the latter is a more well-known word for the same thing.
                'candlestick' and 'lead pining' were shortened.
                'revolver' was altered to the synonymous 'handgun'.
                This was done to ensure that all card names have a different first letter (which may be useful when we want to use concise notations for them).
            </p>
            <p>
                We will use the set \(\textrm{Cards} = \textrm{Weapons} \cup \textrm{Suspects}\) to refer to the set of all cards.
                There are three different players. We refer to them as 1, 2 and 3.
                That is, Players = {1, 2, 3}.
                The case file envelope is denoted by the singleton set Envelope = {\(\textrm{env}\)}
            </p>
            <p>
                Each player or envelope might have a certain card, and therefore we will make use of the notation \(i_j\).
                Here, \( i \in \textrm{Cards} \)
                and \(j \in \textrm{Players} \cup \textrm{Envelope}\). An example is \(\textrm{revolver}_2\), meaning that player 2 has the revolver.
                In the example \(\textrm{Scarlet}_{\textrm{env}}\), Scarlet is the suspect that is in the case file envelope.
            </p>
        </div>
        <!-- 5.1.2 Rules that players can use to determine more information -->
        <div id="formal-rules">
            <h3>Rules that players can use to determine more information</h3>
            In a game of clue, some logical rules apply.
            Players can use these rules to update their knowledge on the game.
            <ol>
                <li> If one player has a certain card, then the other player cannot have that card.
                    If \(card_i\) with \(card \in \textrm{Cards}\) and
                    \(i \in \textrm{Players} \cup \textrm{Envelope}\),
                    then \(\neg card_j\) with \(j \in \textrm{Players} \cup \textrm{Envelope}\) and
                    \(i \neq j\).
                    That is, \(card_i \rightarrow \neg card_j\) for \(i \neq j\).
                </li>
                <br>
                <li>
                    If you know that a player has a card, then they have that card.
                    If player \(i\) knows that player \(j\) has a card \(card\) with
                    \(i, j \in \textrm{Players} \cup \textrm{Envelope}\) and \(card \in \textrm{Cards}\),
                    then player \(j\) has that card.
                    So, \(K_i card_j \rightarrow card_j\).<br>
                    <strong>\(K_i (card_j \rightarrow card_j)\) or \((K_i card_j) \rightarrow card_j\)</strong>

                </li>
                <br>
                <li>
                    If each player has \(n\) cards and player \(i\) knows that player \(j\) has the set \(Cards_j\)
                    with \(|Cards_j| = n\) (here, we use absolutes to denote the size),
                    then if \(card \notin Cards_j\): \(\neg card_j\).
                    Thus, \((card \notin Cards_j \textrm{ and } |Cards_j| = n) \rightarrow \neg card_j\).
                </li>
                <br>
                <li>
                    If all except one of \(\textrm{Players} \cup \textrm{Envelope}\) does not have a certain card, then the remaining player or envelope must have this card. <br>
                    \(\neg card_i \textrm{ and } \neg card_j \textrm{ and } \neg card_k \rightarrow card_l\) with \(i, j \in \textrm{Players} \cup \textrm{Envelope}\) and \(i \neq j \neq k \neq l\).
                </li>
                <br>
                <li>
                    If for all except one weapons in \(Weapons\) or for all except one suspects in \(Suspects\), you know that they belong to any player, then the remaining weapon or suspect is in the envelope.
                    \(\neg card_i \textrm{ and } \neg card_j \textrm{ and } \neg card_k \rightarrow card_l\) with \(i, j \in \textrm{Players} \cup \textrm{Envelope}\) and \(i \neq j \neq k \neq l\).
                </li>
            </ol>
        </div>
    </div>
    <!-- subsection 5.2: kripke model -->
    <div id="the-kripke-model">
        <h2>The Kripke Model</h2>
        <strong>[TODO: add a formal definition of the Kripke model.]<br></strong>
        <p>
            The Kripke model should represent the state combinations that include four weapons,
            four suspects and three players.
            There is one weapon card and one suspect card in the envelope.
            This means that there are \(4 \times 4 = 16\) possibilities for the envelope.
            For the three players, there are six cards left (weapons and suspects combined).
            This leads to there being \(\frac{6!}{2! \times (6-2)!} = 15\) possible card combinations for player 1.
            When two of the six cards are given to player 1, that leaves four cards for player 2.
            In effect, there are \(\frac{4!}{2! \times (4-2)!} = 6\) possible combinations for player 2.
            For player 3 there is only one option: they are left with the \(4 - 2 = 2\) remaining cards.
            In total, this all results in \(16 \times 15 \times 6 \times 1 = 1440\) states.
        </p>
        <p>
            Each state contains one of the possible combinations of the 8 weapon and suspect cards.
            As an example, one such state is given by:
            candlestick\(_1\), dagger\(_1\),
            rope\(_2\), Scarlet\(_2\), Mustard\(_3\),
            Green\(_3\), wrench\(_\textrm{env}\),
            Plum\(_\textrm{env}\).
            Assume that this is the real-life situation, and use the following abbreviations:
            candlestick is c, dagger is d, rope is r, wrench is w, Scarlet is S, Mustard is M,
            Green is G and Plum is P. Now see figure 1, which shows a Kripke model of 3 states and their relations.
            The actual real-life state is shown in the top left.
        </p>
        <figure>
            <img src="figures/example_kripke.png" alt="kripke_example" style="width:100%">
            <figcaption>Fig.1 - Kripke model with 3 states and its relations.</figcaption>
        </figure>
        <p>
            As far as relations go, the envelope does not have any relations,
            since we do not care about potential ways that the envelope can have the same card
            and about what the envelope `knows'. For the players, each player has relations
            from a state to another state if that players has the same cards in both states.
            From the previous example, player 1 has the candlestick and dagger in that state,
            so from that state can reach any state where they also have the candlestick and dagger.
        </p>

        <p>
            Now consider figure 1 and the relations that are shown there.
            Agent 1 can reach state 1 and 3. Agent 2 can only reach state 1. Lastly, agent 3
            can reach state 1 and 2. In our model, we decided to only
            keep reflexive relations if the agent considers that state possible, since this
            reduces the amount of relations. A state is considered possible by an agent if
            the cards of that agent in the state correspond to the cards the agent actually has.
            As an example, agent 2 only has a reflexive relation in the top left state.
        </p>
        <p>
            The Kripke model is updated during every time step.
            Firstly, using public announcement when not showing a card.
            Secondly, using a private announcement when showing a card.
            Thirdly, the additional rules as described in the previous subsection are used.
        </p>
        <p>
            A player knows the cards in the envelope and will guess the cards in the envelope
            when all possible states that agent can reach have the same cards in the envelope.
    </div> <!-- subsection 5.2: the kripke model -->
</div>  <!-- section 5: implementation-->
<!-- section 6: what happens during a turn? -->
<div id="taking-a-turn">
    <h1>What happens during a turn</h1>
    <!--6.1 Asking for cards: showing a card-->
    <div id="show-a-card"> <!--6.1 Asking for cards: showing a card-->
        <h2>Asking for cards: showing a card</h2>
        <strong>[TODO: explain this and work out using an example.]<br></strong>
        <p>
            During a turn a player can ask another player for 2 cards: a weapon and a suspect.
            If this player has one of those cards,
            this card will be shown only to the player who asked for the card.
            This is a private announcement and action models can be used to show the update of the Kripke model after showing a card.
            We will now consider two examples of what happens when agent 2 shows a card to agent 1.
            The difference between these two scenarios is the amount of knowledge agent 3 has.
        </p>

        <figure>
            <img src="figures/kripke_show_card_3_knows2.png" alt="kripke_example" style="width:100%">
            <figcaption>Fig.2 - Kripke model showing updates of the model after player 2 shows a cards and player 3 can
                determine the card.</figcaption>
        </figure>
        <p>
            Consider figure 2 and the following scenario: Player 1 asks player 2: {dagger, Scarlet}.
            Player 2 has Scarlet, and thus shows this card. Agent 3 already knows that agent 1 has the dagger.
        </p>
        <p>
            Step 1 shows the original model. Step 2 shows the model after agent 1 has updates its
            relations. Agent 2 has shown agent 1 the Scarlet card, so agent 1 removes all relations to states where
            player 2 does not have Scarlet, since those states are no longer possible. As can be seen in figure 2,
            this corresponds to agent 1 removing the relation from state 1 to state 3 and the reflexive relation of
            state 3. In step 3, player 3 updates its relations. This figure considers the scenario where agent 3 already
            knows that agent 1 has the dagger. Since agent 1 asked for {dagger, Scarlet} and was shown a card, it must
            be the case that agent 2 has Scarlet. So, agent 3 removes all relations to states where player 2 does not
            have Scarlet. In the last step, we remove one-sided relations, since those start from a state that is
            impossible for the respective agent and therefore are not relevant for finding the content of the envelope.
            Moreover, states without relations are removed to clarify which potential states are still possible.
            In this small example, only the actual state remains after all agents have updated their relations.
        </p>
        <figure>
            <img src="figures/kripke_show_card_3_does_not_know.png" alt="kripke_example" style="width:100%">
            <figcaption>Fig.3 - Kripke model showing updates of the model after player 2 shows a cards and player 3
                cannot determine the card.</figcaption>
        </figure>
        <p>
            For figure 3, player 1 asks player 2: {candlestick, Scarlet}. Player 2 has Scarlet, and thus shows this card.
            Agent 3 does not know that agent 1 has the candlestick. More specifically, agent 3 considers state 2 as
            a possibility and here agent 2 has the candlestick.
        </p>
        <p>
            Step 1 and 2 are the same as for the scenario in figure 2, because agent 1 still sees the same card and updates
            the same relations. During step 3, agent 3 updates its relations while knowing
            less information than in the previous scenario. Agent 3 does not know that agent 1 has the candlestick, but
            can still gather some information from agent 2 showing a card to agent 1. More precisely, agent 3 knows
            that agent 2 has either the candlestick or Scarlet card or both. So, agent 3 can remove relations to all states
            where player 2 does not have the candlestick and does not have Scarlet. In this example, this corresponds
            to keeping all existing relations, since all relations of agent 3 point to states where player 2 has either
            the candlestick or Scarlet. For step 4, irrelevant relations and states are removed again. Here, more
            potential states are still considered possible by agent 3 than only the actual state.
        </p>
    </div>
    <!-- 6.2 Asking for cards: not showing a card -->
    <div id="dont-show-a-card"> <!-- 6.2 Asking for cards: not showing a card -->
        <h2>Asking for cards: not showing a card</h2>
        <strong>[TODO: explain this and work out using an example.]<br></strong>
        <p>
            During a turn a player can ask another player for 2 cards: a weapon and a suspect.
            If this player does not have those cards, then no card will be shown.
            This is a public announcement and action models can be used to show
            the update of the Kripke model after not showing any card.
        </p>
        <figure>
            <img src="figures/kripke_do_not_show_card_option2.png" alt="kripke_example" style="width:100%">
            <figcaption>Fig.4 - Kripke model showing updates of the model after player 2 does not show a card.</figcaption>
        </figure>
        <p>
            Consider figure 4 and the scenario: player 1 asks player 2 {candlestick, Green}. Player 2 does not have
            these cards and hence cannot show any cards. Step 1 shows the original model. Step 2 and 3 show respectively
            agent 1 and 3 updating their relations. Both of them know that agent 2 does not have the candlestick and
            does not have Green, so they can remove any states where agent 2 has the candlestick and any state where
            agent 2 has Green. For agent 1 this corresponds to removing relations to state 3, because here agent 2 has
            Green. For agent 3, relations to state 2 are removed, since here agent 2 has the candlestick. In step 4
            all irrelevant relations and states are removed, leaving only the actual state.
        </p>
    </div>
    <!--6.3 6.3 ‘Guessing’ the content of the envelope-->
    <div id="guess-envelope-content"> <!--6.3 ‘Guessing’ the content of the envelope-->
        <h2>'Guessing' the content of the envelope</h2>
        <p>
            If a player knows the content of the envelope,
            then this player will `guess' the content of the envelope.
            If this player is correct, they win the game and the game ends.
        </p>
    </div>
    <!--6.4 After a turn: updating the model -->
    <div id="model-update">
        <h2>Updating the model using the Clue rules</h2>
        <p>
            After showing/not showing any cards, the Kripke model of players is updated and the turn of that player ends.
            More knowledge might be part of the system than you might initially think.
            As explained in the formal rules section above, a player might determine which card was shown using logic.
            However, in our Kripke model this is already implemented without adding extra rules.
        </p>
        <p>
            Consider for example the rule: if one player has a certain card, then another player cannot have that card.
            In the Kripke model, if a player knows that some player has a card, then all states will be removed where
            that player does not have the card. Hence, all states where another player has the card are removed, so
            another player cannot have the card in question.
        </p>
        <p>
            The rules can be worked out and after checking all of them, we came to the conclusion that our Kripke
            model with public and private announcements already handle all rules discussed.
        </p>
    </div> <!--6.4 After a turn: updating the model-->
</div>
<!-- download the implementation here-->
<!-- TODO: ability to download model/remove section -->
<br>
<div id="download-the-model">
    <h1> Download the model here.</h1>
</div>
